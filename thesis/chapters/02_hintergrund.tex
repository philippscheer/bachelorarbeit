\section{Hintergrund}


\subsection{Problemstellung}

Das Student Scheduling Problem (SSP), also die Erstellung eines optimalen Semesterplans, ist eine zentrale Herausforderung für Studierende. Sie sehen sich im Hauptstudium mit einem umfangreichen Kursangebot konfrontiert, dessen Veranstaltungen sich in zahlreichen Terminkonstellationen überlappen können. Die Herausforderung besteht darin, aus diesem Pool an Lehrveranstaltungen eine zulässige und optimale Kombination zu wählen.

Die Problemstellung ist komplex: Einerseits müssen Hard Constraints wie Überlappungsfreiheit und Erfüllung einer Mindestanzahl von ECTS pro Semester erfüllt sein. Andererseits gilt es, Präferenzen, die als Soft Constraints ausgedrückt werden, zu maximieren, die die Lebensrealität der Studierenden widerspiegeln. Dazu zählen etwa die Berücksichtigung von Arbeitstätigkeiten, die durch Blockieren oder Priorisieren von gewissen Stunden in der Woche ausgedrückt werden, sowie die Favorisierung von Kursen, die durch eine Priorität ausgedrückt wird.

In dieser Arbeit wird das SSP für einen einzelnen Studierenden des Hauptstudiums Wirtschaftsinformatik (inklusive CBK) betrachtet und als ein Constaint-Satisfaction Problem (CSP) formuliert. Ziel ist eine möglichst akkurate Implementierung der Algorithmen, die Feldman und Golumbic im Paper "\textit{Optimization Algorithms for Student Scheduling via Constraint Satisfiability}" \cite{feldmangolumbic} beschreiben, um diese anschließend miteinander zu vergleichen.



\subsection{Motivation}

% TODO: Vergleich mit ÖH LV-Planer



\subsection{Zielsetzung}

Die vorliegende Bachelorarbeit verfolgt das Ziel, die beschriebenen Optimierungsalgorithmen unter aktuellen Bedingungen und mit einem aktuellen Datensatz zu validieren und einen Leistungsvergleich anzustellen.

\begin{enumerate}
    \item Validierung: Zentral ist die exakte Nachprogrammierung der Algorithmen von Feldman und Golumbic \cite{feldmangolumbic}. Es soll überprüft werden, ob diese Algorithmen auch unter modernen Rechenbedingungen und mit realen Daten aus dem Vorlesungsverzeichnis der Wirtschaftsuniversität Wien einen optimalen Semesterplan erstellen können.
    \item Vergleichende Leistungsanalyse: Die implementierten Algorithmen werden hinsichtlicher der Qualität ("Score") der gefundenen Lösung, Geschwindigkeit und Speichernutzung verglichen.
\end{enumerate}



\subsection{Zeittafelprobleme}

% TODO paper


\subsubsection{Hill-Climbing Algorithmen}

Hill-Climbing Algorithmen gehören zur Klasse der lokalen Such- und Optimierungsverfahren. Sie finden gute oder nahezu optimale Lösungen für schwierige (\textit{NP-hard}) Optimierungsprobleme, ohne den gesamten Lösungsraum zu durchsuchen. Der Algorithmus versucht von einem Zustand in einen benachbarten Zustand mit besserem Zielfunktionswert überzugehen --- ähnlich wie das Erklimmen eines Hügels, auf einer Landschaft, wobei die "Höhe" des Hügels die Qualität der Lösung darstellt.

Diese Vorgehensweise macht sie besonder effizient für große, aber gut strukturierte Optimierungsprobleme, da in kurzer Zeit eine gute Lösung gefunden werden kann. Die Implementierung ist unkompliziert, was Hill-Climbing Algorithmen in vielen Anwendungsbereichen zu einem beliebten heuristischen Ansatz macht. Ein wesentlicher Nachteil liegt in der Tendenz, in lokalen Optima zu verharren. Da der Algorithmus in seiner Grundform nur Verbesserungen akzeptiert, werden lokale Minima nicht durchschritten, selbst wenn sich dahinter ein höheres Maxima befindet \cite{jacobson-2004}.


% TODO pseudo code (adp)


\subsubsection{Offering-Order Algorithmus}

Der Offering-Order Algorithmus, welcher von Feldman und Golumbic \cite{feldmangolumbic} beschrieben wird, kombiniert ein heuristisches Ordnungsverfahren mit einer \textit{Tree Search}. Der Kern des Ansatzes besteht darin, eine heuristisch bestimmte Reihenfolge für die Instanziierung der Variablen (Kurse) festzulegen --- die sogenannte "\textit{offering order}". Innerhalb ihrer Planpunkte werden somit alle Kurse vorsortiert. Mittels einer Vorwärts-Suche wird der vorsortierte Suchbaum durchsucht, um dem aktuellen Zustand einen weiteren Kurs hinzuzufügen. Führt der neue Zustand zu einem ungültigen Ergebnis, wird der letzte gültige Zustand wiederhergestellt ("\textit{back-tracking}").

Durch die Wahl einer sinnvollen Reihenfolge lassen sich ineffiziente Suchpfade vermeiden. Auf diese Weise wird der Suchraum stark reduziert und es kann eine Lösung gefunden werden, ohne den gesamten Lösungsraum zu besuchen.

% TODO: nachteile + pseudo code



\subsubsection{Integer Linear Programming (ILP)}




\subsection{Replikationsarbeit}




\subsection{Abgrenzung}
Folgende Aspekte sind explizit vom Forschungsumfang ausgeschlossen:

\begin{enumerate}
    \item Das Problem wird ausschließlich als SSP für einen einzelnen Studierenden gelöst. Es wird keine Rücksicht auf andere Studierende, die maximale Kapazität von Räumen, die Verfügbarkeit von Professoren oder die allgemeine universitäre Ressourcenplanung genommen.
    \item Die Planung beschränkt sich auf ein einzelnes Semester des Hauptstudium Wirtschaftsinformatik.
    \item Die Entwicklung einer voll funktionsfähigen Applikation zur Dateneingabe, Speicherung von Planungen, oder komplexer Visualisierung wird ausgeschlossen. Das Ergebnis des Programms wird durch ein computerlesbares Format (JSON) ausgegeben.
\end{enumerate}


\subsection{Aufbau}

Die vorliegende Arbeit gliedert sich in vier Hauptkapitel:

Nach dieser Einleitung, welche Problemstellung, Zielsetzung und Abgrenzung erklärt, folgt das Kapitel Hintergrund und theoretische Grundlagen. Hier werden die Struktur des Studiums an der WU und die daraus resultierenden Herausforderungen bei der Stundenplanerstellung erläutert. Weiters werden die Grundlagen der Optimierung und Constraint-Satisfaction Probleme als theoretische Basis erklärt.

Das zentrale Kapitel Implementierung beschreibt die notwendige Datenbeschaffung aus dem Vorlesungsverzeichnis. Anschließend wird die technische Implementierung der Algorithmen in Python detailliert erklärt.

Das Kapitel Zusammenfassung und Arbeit zeigt die Ergebnisse der vergleichenden Analyse der implementierten Algorithmen hinsichtlich der Lösungsqualität, Geschwindigkeit und Speichernutzung. Die Ergebnisse der Analyse werden mit den Ergebnissen im Paper verglichen. Die Arbeit schließt mit dem Fazit und der Skizzierung möglicher Weiterentwicklungen und Anwendungsfälle.


